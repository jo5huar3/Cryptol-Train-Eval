{"task_id":1,"type":"function","task":"# Task\nWhen running the specification I got an error. Explain what is causing the error and how to fix it.\n\n## Soure Code\n```cryptol\nmatrix : {n, m} (fin n, fin m) => [_][m]([width n], [width m])\nmatrix = [[(i, j) | j <- [0 .. m - 1]] | i <- [0 .. n - 1]]\n```\n\n## Error\n[error] at a.cry:2:1--2:60:\n  Failed to validate user-specified signature.\n    in the definition of 'Main::matrix', at a.cry:2:1--2:7,\n    we need to show that\n      for any type n, m\n      assuming\n        \u2022 fin n\n        \u2022 fin m\n      the following constraints hold:\n        \u2022 width m >= width (m - 1)\n            arising from\n            use of finite enumeration\n            at a.cry:2:26--2:38\n        \u2022 width n >= width (n - 1)\n            arising from\n            use of finite enumeration\n            at a.cry:2:47--2:59\n        \u2022 m >= 1\n            arising from\n            use of partial type function (-)\n            at a.cry:2:26--2:38\n        \u2022 n >= 1\n            arising from\n            use of partial type function (-)\n            at a.cry:2:47--2:59","test_setup_code":"","test_list":"","challenge_test_list":[]}
{"task_id":2,"type":"function","task":"Implement a function named `matrix` which takes no input and returns a 3 x 3 matrix of tuples. For the function use a nested comprehension to write an expression to produce a 3 \u00d7 3 matrix (as a sequence of sequences), such that the ijth entry contains the value (i, j).","test_setup_code":"","test_list":"","challenge_test_list":[]}
{"task_id":3,"type":"function","task":"Implement a Caesar cipher. Define the functions `encrypt` and `decrypt` with the signature: `{n} [8] -> [n][8] -> [n][8]`.","test_setup_code":"","test_list":"","challenge_test_list":[]}
{"task_id":4,"type":"property","task":"Using ONLY the functions and constraints provided, create a monomorphic Cryptol property named `equivalent` that proves decrypt inverts encrypt for a 512-byte plaintext.","test_setup_code":"encryptChar : [8] -> [8] -> [8]\nencryptChar key c = (c + key)\ndecryptChar : [8] -> [8] -> [8]\ndecryptChar key c = (c - key)\nencrypt : {n} [8] -> [n][8] -> [n][8]\nencrypt key txt = [ encryptChar key c | c <- txt ]\ndecrypt : {n} [8] -> [n][8] -> [n][8]\ndecrypt key txt = [ decryptChar key c | c <- txt ]","test_list":"","challenge_test_list":[]}
{"task_id":5,"type":"function","task":"Write a Cryptol module `Primitive::Keyless::Hash::SHA2::Instantiations::SHA384` that imports the generic SHA-2 specification for SHA-384. Use `type DigestSize = 384`, `type w = 64`, and initialize the hash vector as `H0 = [\n        0xcbbb9d5dc1059ed8, 0x629a292a367cd507,\n        0x9159015a3070dd17, 0x152fecd8f70e5939,\n        0x67332667ffc00b31, 0x8eb44a8768581511,\n        0xdb0c2e0d64f98fa7, 0x47b5481dbefa4fa4\n    ]\n`","test_setup_code":"","test_list":"","challenge_test_list":[]}
{"task_id":6,"type":"function","task":"Write a Cryptol module `Primitive::Symmetric::Cipher::Block::AES::ExpandKey` that imports the generic `GF28`, `State`, and `SubByteSBox` of the AES encryption modules. Define `type Nk` and `type Nr` as parameters with the constraints that `Nk >= 1` with `8 >= width` and `Nr >= 2` with `8 >= width`. Define the functions `expandKey : [32 * Nk] -> (RoundKey, [Nr-1]RoundKey, RoundKey)`, `expandKeyForever : [Nk][4][8] -> [inf]RoundKey`, `keyWS : [Nk][4][8] -> [inf][4][8]`, `Rcon : [8] -> [4]GF28`, `SubWord : [4]GF28 -> [4]GF28`, `RotWord : [4]GF28 -> [4]GF28`, and `NextWord : [8] ->[4][8] -> [4][8] -> [4][8]`. The module should perform AES key expansion. The type `RoundKey` is defined in the `State` module as the following.","test_setup_code":"module Primitive::Symmetric::Cipher::Block::AES::ExpandKey where\n\nimport Primitive::Symmetric::Cipher::Block::AES::GF28\nimport Primitive::Symmetric::Cipher::Block::AES::State\nimport Primitive::Symmetric::Cipher::Block::AES::SubByteSBox\n\nparameter\n\n  type Nk : #\n  type constraint (8 >= width Nk, Nk >= 1)\n\n  type Nr : #\n  type constraint (8 >= width Nr, Nr >= 2)\n\nexpandKey : [32 * Nk] -> (RoundKey, [Nr-1]RoundKey, RoundKey)\nexpandKey key = ( keys @ 0\n                , keys @@ ([1 .. (Nr - 1)] : [_][8])\n                , keys @ (`Nr : [8])\n                )\n  where   seed : [Nk][4][8]\n          seed = split (split key)\n          keys = expandKeyForever seed\n\nexpandKeyForever : [Nk][4][8] -> [inf]RoundKey\nexpandKeyForever seed = [ transpose g | g <- split (keyWS seed) ]\n\nkeyWS : [Nk][4][8] -> [inf][4][8]\nkeyWS seed    = xs\n     where xs = seed # [ NextWord i prev old\n                       | i    <- [ `Nk ... ]\n                       | prev <- drop`{Nk-1} xs\n                       | old  <- xs\n                       ]\n\nRcon : [8] -> [4]GF28\nRcon i = [ gf28Pow <| x |> (i-1), 0, 0, 0]\n\nSubWord : [4]GF28 -> [4]GF28\nSubWord bs = [ SubByte b | b <- bs ]\n\nRotWord : [4]GF28 -> [4]GF28\nRotWord [a0, a1, a2, a3] = [a1, a2, a3, a0]\n","test_list":"","challenge_test_list":[]}
{"task_id":7,"type":"function","task":"Write a Cryptol specification that defines an incremental averaging state machine. The specification should define the type `State` to contain a sum of all values and the amount of values as two 32-bit words, the functions `init` to initialize `State`, `appendf` that adds a value to `sum'` and increments `len`, `digest` that returns the average in the `State`, and `avg` with signature `avg : {n} (fin n, 32 >= width n) => [n][32] -> [32]` to compute the averages of a sequence.","test_setup_code":"","test_list":"","challenge_test_list":[]}
{"task_id":8,"type":"function","task":"Write a Cryptol module `Test` that imports `Cipher`. Define the function `evktest : {ks, bs, n} (fin bs) => (Cipher ks bs, [n]([ks],[bs]), [bs]) -> [n]([bs], Bit)`, that takes a cipher, `n` key and test vector tuples, and plain text. The function test that using the cipher\u2019s `encrypt` to encrypt the plain text with each key from the test vectors will produce the cipher text in the test vectors. The function returns `n` tuples containing the cipher text produced by encrypting the plain text with each test key and a boolean value whether the cipher text matches the expected test vector.","test_setup_code":"","test_list":"","challenge_test_list":[]}
{"task_id":9,"type":"function","task":"Define a Cryptol module `ECDSA_test` with imports `Common::utils` and `Primitive::Asymmetric::Signature::ECDSA::p192 as p192`. Define a property for the function `G_compress R = ec_compress (ec_affinify G) == R` from the p192 module. Use the value `0x00000003188da80eb03090f67cbf20eb43a18800f4ff0afd82ff1012` in your property.","test_setup_code":"","test_list":"","challenge_test_list":[]}
{"task_id":10,"type":"function","task":"Define a Cryptol module `bivium` that generates the infinite keystream as specified by the Bivium stream cipher. Define the function `bivium_stream : [93] -> [84] -> [inf]` which takes two initial shift registers of lengths 93 and 84 bits and returns the infinite keystream according to the Bivium algorithm. Define `type N = 200`, and a function `Bivium : ([93], [84]) -> [N]Bit` which takes the two initial registers as a pair and returns the first N bits of the keystream returned from `bivium_stream`. Define the helper functions: `shift : {d} (fin d, d >=1) => [d] -> Bit -> [d]` that returns `fills` where `fills = [bit]#(drop`{1} (fill >> 1))`. The function `shift_regs : {d,e} (fin d, fin e, d >=1, e >=1) => [d] -> [e] -> ([inf],[inf][d],[inf][e])` that, given 2 initial registers, returns a tuple containing the infinite keystream, the infinite stream of `r1`, and the infinite stream of `r2`.","test_setup_code":"","test_list":"","challenge_test_list":[]}
{"task_id":11,"type":"function","task":"Write a Cryptol module `Primitive::Asymmetric::Signature::ECDSA::Instantiations::ECDSA_P521_SHA3_512` that imports the generic `ECDSA::UnconstrainedSpec`. Instantiate it with the  `EC = Common::EC::PrimeField::Instantiations::P521` and `Hash = Primitive::Keyless::Hash::SHA3::Instantiations::SHA3_512`.","test_setup_code":"","test_list":"","challenge_test_list":[]}
{"task_id":12,"type":"function","task":"Write a Cryptol module `Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon96_96` that imports the generic Simon specification for Simon96_96. Use `type n = 48`, `type m = 2`, `type T = 52`, and `type j = 2`.","test_setup_code":"","test_list":"","challenge_test_list":[]}
{"task_id":13,"type":"function","task":"Write a Cryptol specification for a parameterized SHA-2 style hash function over word size w, defining sha : {L} (2 * w >= width L) => [L] -> [digest_size] and all supporting types, constants (H0, K), and functions (padding, parsing, message schedule, compression, and block processing).","test_setup_code":"","test_list":"","challenge_test_list":[]}
{"task_id":14,"type":"function","task":"Using the existing type `Cipher` and value `toyCipher` provided in the test setup, define a single polymorphic Cryptol function named `evktest` with the following type:\n\nevktest : {ks, bs, n} (fin bs)\n       => (Cipher ks bs, [n]([ks],[bs]), [bs]) -> [n]([bs], Bit)\n\nThe function should take a cipher implementation, a sequence of (Key, Ciphertext) test vectors, and a single plaintext block. For each (Key, CT) in the list, it must iterate over that list using a single generator in a list comprehension (no parallel generators or multiple `|` arms), compute CT' = cipher.encrypt Key PT for that entry, and produce an output list of pairs (CT', CT' == CT).\n\nThe code for `Cipher` and `toyCipher` is ALREADY present in the file from the test setup code. In your answer, you MUST NOT repeat, modify, or redefine `Cipher` or `toyCipher`, and you MUST NOT add any other top-level declarations.\n\nYour entire answer must consist of exactly two top-level lines: (1) the type signature for `evktest` exactly as given above, and (2) the definition of `evktest`. Do not wrap these in a module declaration, and do not include any setup code.","test_setup_code":"type Cipher ks bs =\n  { encrypt : [ks] -> [bs] -> [bs]\n  , decrypt : [ks] -> [bs] -> [bs]\n  }\n\ntoyCipher : Cipher 8 8\ntoyCipher = {\n  encrypt = \\k pt -> k ^ pt,\n  decrypt = \\k ct -> k ^ ct\n}\n","test_list":"","challenge_test_list":[]}
{"task_id":15,"type":"property","task":"Using ONLY the SHA-512 specification provided in the test setup (which defines a function `sha512` and all supporting constants), define a Cryptol property named `testVector1` with no arguments that checks `sha512` against the following fixed known-answer test vector:\n\n- Message (as a hex literal): 0x616263\n- Expected digest (as a hex literal): 0xddaf35a193617abacc417349ae20413112e6fa4e89a97ea20a9eeee64b55d39a2192992a274fc1a836ba3c23a3feebbd454d4423643ce80e2a9ac94fa54ca49f\n\nThe property must *exactly* assert that `sha512` of this message equals this digest.\n\nThe full definition of `sha512` (and all helper functions and constants) is ALREADY present in the file from the test setup code. In your answer, you MUST NOT repeat, modify, or redefine `sha512` or any of its helpers, and you MUST NOT add any other top-level declarations.\n\nYour entire answer must be a single top-level declaration starting with:\n\nproperty testVector1 =\n\nand it must directly assert that `sha512 0x616263` equals the given digest, using those exact hex constants. Do not introduce any arguments, do not wrap it in a module, and do not include any setup code.","test_setup_code":"sha512 M = result\n  where\n    M' = (pad M)\n    blocks = (groupBy`{1024} M')\n    hash = [H0] # [ processBlock b h | b <- blocks | h <- hash ]\n    result = (join (hash!0))\n\nprocessBlock : [1024] -> [8][64] -> [8][64]\nprocessBlock block Hprev = Hs\n  where\n    Mi = split block : [16][64]\n    Ws = (messageSch Mi)\n    round = [Hprev] # [ (step r (Ws@t) t) | t <- [0..79] | r <- round ]\n    Hs = [ (x + H) | x <- (round!0) | H <- Hprev ]\n\nstep : [8][64] -> [64] -> [8] -> [8][64]\nstep [a, b, c, d, e, f, g, h] Wt t = [a', b', c', d', e', f', g', h']\n  where\n    T1 = h + (SIGMA1 e) + (Ch e f g) + (K@t) + Wt\n    T2 = (SIGMA0 a) + (Maj a b c)\n    h' = g\n    g' = f\n    f' = e\n    e' = d + T1\n    d' = c\n    c' = b\n    b' = a\n    a' = T1 + T2\n\nmessageSch : [16][64] -> [80][64]\nmessageSch Mi = W\n  where\n    W = Mi # [ (sigma1 (W@(t-2))) + (W@(t-7)) + (sigma0 (W@(t-15))) + (W@(t-16)) | t <- [16..79] ]\n\npad : {l, k} (fin l,\n              l <= ((2^^128) - 1),\n              l >= 0,\n              fin k,\n              k - l >= 129,\n              k == 128 + l + 1 + 1024 - ((l+129)%1024),\n              k%1024 == 0) => [l] -> [k]\npad M = M # (1:[1]) # (0:[k-128-l-1]) # (`l:[128])\n\nCh : [64] -> [64] -> [64] -> [64]\nCh x y z = (x && y) ^ ((~x) && z)\n\nMaj : [64] -> [64] -> [64] -> [64]\nMaj x y z = (x && y) ^ (x && z) ^ (y && z)\n\nSIGMA0 : [64] -> [64]\nSIGMA0 x = (x >>> 28) ^ (x >>> 34) ^ (x >>> 39)\n\nSIGMA1 : [64] -> [64]\nSIGMA1 x = (x >>> 14) ^ (x >>> 18) ^ (x >>> 41)\n\nsigma0 : [64] -> [64]\nsigma0 x = (x >>> 1) ^ (x >>> 8) ^ (x >> 7)\n\nsigma1 : [64] -> [64]\nsigma1 x = (x >>> 19) ^ (x >>> 61) ^ (x >> 6)\n\nH0 = [ 0x6a09e667f3bcc908, 0xbb67ae8584caa73b, 0x3c6ef372fe94f82b, 0xa54ff53a5f1d36f1,\n       0x510e527fade682d1, 0x9b05688c2b3e6c1f, 0x1f83d9abfb41bd6b, 0x5be0cd19137e2179 ]\n\nK = [\n0x428a2f98d728ae22, 0x7137449123ef65cd, 0xb5c0fbcfec4d3b2f, 0xe9b5dba58189dbbc,\n0x3956c25bf348b538, 0x59f111f1b605d019, 0x923f82a4af194f9b, 0xab1c5ed5da6d8118,\n0xd807aa98a3030242, 0x12835b0145706fbe, 0x243185be4ee4b28c, 0x550c7dc3d5ffb4e2,\n0x72be5d74f27b896f, 0x80deb1fe3b1696b1, 0x9bdc06a725c71235, 0xc19bf174cf692694,\n0xe49b69c19ef14ad2, 0xefbe4786384f25e3, 0x0fc19dc68b8cd5b5, 0x240ca1cc77ac9c65,\n0x2de92c6f592b0275, 0x4a7484aa6ea6e483, 0x5cb0a9dcbd41fbd4, 0x76f988da831153b5,\n0x983e5152ee66dfab, 0xa831c66d2db43210, 0xb00327c898fb213f, 0xbf597fc7beef0ee4,\n0xc6e00bf33da88fc2, 0xd5a79147930aa725, 0x06ca6351e003826f, 0x142929670a0e6e70,\n0x27b70a8546d22ffc, 0x2e1b21385c26c926, 0x4d2c6dfc5ac42aed, 0x53380d139d95b3df,\n0x650a73548baf63de, 0x766a0abb3c77b2a8, 0x81c2c92e47edaee6, 0x92722c851482353b,\n0xa2bfe8a14cf10364, 0xa81a664bbc423001, 0xc24b8b70d0f89791, 0xc76c51a30654be30,\n0xd192e819d6ef5218, 0xd69906245565a910, 0xf40e35855771202a, 0x106aa07032bbd1b8,\n0x19a4c116b8d2d0c8, 0x1e376c085141ab53, 0x2748774cdf8eeb99, 0x34b0bcb5e19b48a8,\n0x391c0cb3c5c95a63, 0x4ed8aa4ae3418acb, 0x5b9cca4f7763e373, 0x682e6ff3d6b2b8a3,\n0x748f82ee5defb2fc, 0x78a5636f43172f60, 0x84c87814a1f0ab72, 0x8cc702081a6439ec,\n0x90befffa23631e28, 0xa4506cebde82bde9, 0xbef9a3f7b2c67915, 0xc67178f2e372532b,\n0xca273eceea26619c, 0xd186b8c721c0c207, 0xeada7dd6cde0eb1e, 0xf57d4f7fee6ed178,\n0x06f067aa72176fba, 0x0a637dc5a2c898a6, 0x113f9804bef90dae, 0x1b710b35131c471b,\n0x28db77f523047d84, 0x32caab7b40c72493, 0x3c9ebe0a15c9bebc, 0x431d67c49c100d4c,\n0x4cc5d4becb3e42b6, 0x597f299cfc657e2a, 0x5fcb6fab3ad6faec, 0x6c44198c4a475817\n]\n","test_list":"","challenge_test_list":[]}
{"task_id":16,"type":"property","task":"Using ONLY the definitions `mk_buggy_fib_no_init`, `generate`, the infix operator `$`, and the sequences `foo` and `bar` provided in the test setup, define a Cryptol property named `fooEqualsBar` with no arguments that asserts that `foo` and `bar` are exactly equal. Do not redefine any of these functions or values; only provide the definition of `property fooEqualsBar`.","test_setup_code":"mk_buggy_fib_no_init : {a} (fin a, a >= 1) => [a] ->\n  ([1], ([8], [8], [a])) -> ([8], ([8], [8], [a]))\nmk_buggy_fib_no_init magic (_, (fn, fn1, k)) = (fn', (fn1, fn2, k+1))\n  where\n  fn2 = fn + fn1\n  \/\/ Change output when state has magic value.\n  fn' = fn + if k == magic then 1 else 0\n\ngenerate : {n, ix, a} (fin ix, fin n, n >= 1, ix >= width (n - 1)) => ([ix] -> a) -> [n]a\ngenerate f = [ f i | i <- [0 .. n-1] ]\n\ninfixl 1 $\nf $ x = f x\n\nfoo : [10][4]\nfoo = generate $ \\(i:[8]) -> if i == 0 then 1 else foo@(i-1)\n\nbar : [10][4]\nbar = generate \\(i:[8]) -> if i == 0 then 1 else foo@(i-1)\n","test_list":"","challenge_test_list":[]}
{"task_id":17,"type":"function","task":"Define the function `unflatten : {r,w} (fin r, 5 * w >= r, fin w) => [r] -> [w][5]` that pads its input with zeros and groups it into `w` blocks of 5 elements using `groupBy` in Cryptol. DO NOT include import statements, module declarations, or any other code.","test_setup_code":"","test_list":"","challenge_test_list":[]}
{"task_id":18,"type":"function","task":"Write a Cryptol file that defines the functions `mk_curve_ops`, `ec_v1`, and `ec_v2`. The definition must follow the exact structure shown in the prompt: `mk_curve_ops` must construct a record containing fields `field`, `v1`, and `v2`, where `v1` calls `ec_v1` on the input parameter and `v2` calls `ec_v2` on the record being constructed. The functions must use the polymorphic types exactly as shown and must access `p.field.v0` correctly in `ec_v2`. The file must contain no module declaration and must consist only of the three definitions.","test_setup_code":"","test_list":"","challenge_test_list":[]}
{"task_id":19,"type":"function","task":"Write a Cryptol module named `T038` that declares an interface submodule `I` providing `x : [8]`, a submodule `F` that imports interface submodule `I` and defines `y = x + 1`, a submodule `P` that imports submodule `F` while exposing submodule `Q`, a submodule `Q` that defines `x = 11`, and finally an interface submodule `J` that imports submodule `F` through `P`. The structure must match the Cryptol module system rules exactly.","test_setup_code":"","test_list":"","challenge_test_list":[]}
{"task_id":20,"type":"function","task":"Reproduce exactly the four foreign function declarations `foreignAndCryptol`, `foreignAndNoCryptol`, `noForeignAndCryptol`, and `noForeignAndNoCryptol`, each using the C calling convention. Implement `foreignAndCryptol` to return its argument unchanged, leave `foreignAndNoCryptol` unimplemented, implement `noForeignAndCryptol` to return `x + 3`, and leave `noForeignAndNoCryptol` unimplemented. The file must contain only these four declarations.","test_setup_code":"","test_list":"","challenge_test_list":[]}
{"task_id":21,"type":"property","task":"Write a Cryptol module implementing parameterized AES encryption and decryption for key sizes 128, 192, and 256 bits. The module must import the AES algorithm, key expansion, and T-box modules exactly as specified, define `encrypt` and `decrypt` in terms of expanded keys, and include a property named `test` verifying that `decrypt k (encrypt k pt) == pt` for all valid keys and all 128-bit plaintexts.","test_setup_code":"","test_list":"","challenge_test_list":[]}
{"task_id":22,"type":"property","task":"Write a complete Cryptol module implementing the Bivium stream cipher. The module must define `Bivium_stream`, `Bivium`, `Bivium_alt`, and all cycle-testing helpers. It must also define the four properties: `Bivium_correct`, `Bivium_search`, `Bivium_search_with_suffix`, and `Bivium_alt_equivalent`, using the exact IVs, suffix, and test keystream provided. The file must match the structure and behavior of the Bivium specification.","test_setup_code":"","test_list":"","challenge_test_list":[]}
{"task_id":23,"type":"property","task":"Write a Cryptol module implementing the FNV-1a 64-bit hash function, including padding, the FNV offset basis, prime constant, the block-processing logic, and a property `testsPass` that verifies the hash of the empty string, \"a\", and \"foobar\" equals the known answer test vectors provided.","test_setup_code":"","test_list":"","challenge_test_list":[]}
{"task_id":24,"type":"function","task":"Write a Cryptol module `Primitive::Keyless::Hash::SHA2::Instantiations::SHA384` that instantiates the generic SHA-2 specification for SHA-384 with 64-bit words, 384-bit digest size, and the given 8-word initial hash vector `H0`.","test_setup_code":"","test_list":"","challenge_test_list":[]}
{"task_id":25,"type":"function","task":"Define a Cryptol module Primitive::Keyless::Hash::SHA3::Tests::SHAKE256 with an xof function imported from the SHAKE256 instantiation and properties k5\u2013k8 that assert xof applied to [], 0b0, 0b11, and 0b110 equals the given 512-bit expected_result constants.","test_setup_code":"","test_list":"","challenge_test_list":[]}
{"task_id":26,"type":"function","task":"Write a Cryptol module that instantiates SHA3-224 and defines properties t1, t5, t72, and t512 that check the hash and hashBytes functions against the given known-answer test vectors.","test_setup_code":"","test_list":"","challenge_test_list":[]}
{"task_id":27,"type":"function","task":"Write a Cryptol specification that models the Kalotan logic puzzle with parents and child as Bits, defines the given constraints (heterosexual parents, kid lying, parents\u2019 statements), and includes properties equivalent to people_types, checkit1, and checkit2 capturing the valid\/invalid configurations.","test_setup_code":"","test_list":"","challenge_test_list":["assert cry.eval_f(':prove people_types')","assert cry.eval_f(':prove checkit1')","assert cry.eval_f(':prove checkit2')"]}
{"task_id":28,"type":"function","task":"Write a Cryptol specification for a parameterized SHA-2 style hash function over word size w, defining sha : {L} (2 * w >= width L) => [L] -> [digest_size] and all supporting types, constants (H0, K), and functions (padding, parsing, message schedule, compression, and block processing).","test_setup_code":"Ch_Alternate : {w} (fin w, w >= 1) => [w] -> [w] -> [w] -> [w]\nCh_Alternate x y z = (x \/\\ y) \\\/ (~x \/\\ z)","test_list":"","challenge_test_list":["assert cry.eval_f(':prove (\\x -> Ch x x x == x)')","assert cry.eval_f(':prove (\\M -> parse (pad M) == split (pad M))')"]}
{"task_id":29,"type":"function","task":"Create a function that performs modulo addition with the signature `mod_add_Z : (Integer, Integer, Integer) -> Integer`. The first parameter is the modulo base.","test_setup_code":"","test_list":"","challenge_test_list":["assert cry.eval_f(':prove (\\x -> Ch x x x == x)')","assert cry.eval_f(':prove (\\M -> parse (pad M) == split (pad M))')"]}
{"task_id":30,"type":"function","task":"Create a function that multiplies a number with itself using modulo multiplication. Define the following functions `mod_mul_Z : (Integer, Integer, Integer) -> Integer` and `mod_sq_Z : (Integer, Integer) -> Integer`. The first parameter should be the modulo base for both functions. `mod_sq_Z` should call `mod_mul_Z` to perform the modulo multiplication.","test_setup_code":"","test_list":"","challenge_test_list":["assert cry.eval_f(':prove (\\x -> Ch x x x == x)')","assert cry.eval_f(':prove (\\M -> parse (pad M) == split (pad M))')"]}
{"task_id":31,"type":"function","task":"Define the function `mod_div_Z : (Integer, Integer, Integer) -> Integer` that performs modulo division between two integers. The modulo base is the first parameter. You should implement Stein's algorithm and call `mod_half_Z` to perform modulo division by 2. The resulting file should only have two functions and be standalone.","test_setup_code":"mod_half_Z : (Integer, Integer) -> Integer\nmod_half_Z (p, x) = if (x % 2 == 0) then x \/ 2 else (x + p) \/ 2\n","test_list":"","challenge_test_list":["assert cry.eval_f(':prove (\\x -> Ch x x x == x)')","assert cry.eval_f(':prove (\\M -> parse (pad M) == split (pad M))')"]}
{"task_id":32,"type":"function","task":"Create a Cryptol specification that performs the SHA-512 message schedule expansion. Define the functions `messageSch : [16][64] -> [80][64]`, `sigma0 : [64] -> [64]`, and `sigma1 : [64] -> [64]` to perform the message expansion.","test_setup_code":"","test_list":"","challenge_test_list":["assert cry.eval_f(':prove (\\x -> Ch x x x == x)')","assert cry.eval_f(':prove (\\M -> parse (pad M) == split (pad M))')"]}
{"task_id":33,"type":"function","task":"Define the property `tcId1080` that checks, for AES-256 Key Wrap with padding in AE mode, that encrypting the plaintext `0x06` under the key `0x3ea9325069ed93a96c331bdd6dd766ec64bbba83a72c69ed75df55043fb0bfd1` with `KWP_AE` produces the expected ciphertext `0x40a9c42012ba38211b800e6e313b6876`, using the helper `check_KWP_AE key pt expected_ct = KWP_AE key pt == expected_ct`.","test_setup_code":"","test_list":"","challenge_test_list":["assert cry.eval_f(':prove (\\x -> Ch x x x == x)')","assert cry.eval_f(':prove (\\M -> parse (pad M) == split (pad M))')"]}
{"task_id":34,"type":"function","task":"Define the Cryptol module `Primitive::Symmetric::Cipher::Block::AES::SubByteSBox` implementing the AES SubBytes and InvSubBytes transformations with functions `SubByte : GF28 -> GF28` and `InvSubByte : GF28 -> GF28`, using `sbox` and `sboxInv` over `GF28` elements.\n","test_setup_code":"","test_list":"","challenge_test_list":""}
{"task_id":35,"type":"function","task":"Write a Cryptol specification for the McEliece KEM low-level Operations module, defining the functions crypto_kem_enc and crypto_kem_dec (and their helper hash functions) with appropriate types and ensuring they match the intended McEliece KEM encryption and decryption behavior.\n","test_setup_code":"","test_list":"","challenge_test_list":""}
{"task_id":36,"type":"function","task":"Specify the Cryptol types and full implementations for load2, bitrev, store8, load8, and transpose_64x64 used in a McEliece KEM utility module, matching the shown bitwise behavior and using the imported Types definitions.\n","test_setup_code":"","test_list":"","challenge_test_list":""}
{"task_id":37,"type":"function","task":"Write a Cryptol module that defines the same ECDSA test properties for NIST curves P-192, P-224, P-256, P-384, and P-521, including point decompression, point addition\/subtraction, doubling, scalar and joint scalar multiplication, and mp_mod_sqrt correctness, matching the constants and structure shown.\n","test_setup_code":"","test_list":"","challenge_test_list":""}
{"task_id":38,"type":"function","task":"Define a Cryptol module implementing the HMAC construction with a SHA-256-based instance `hmacSHA256`, including the helper function `kinit` and the generic `hmac` function with the given polymorphic sizes and type constraints.\n","test_setup_code":"","test_list":"","challenge_test_list":""}
{"task_id":39,"type":"function","task":"Write a Cryptol module that defines properties `fp2_frobenius_prop`, `f6_frobenius_prop`, and `f12_frobenius_prop` asserting that `fp2_frobenius`, `fp6_frobenius`, and `fp12_frobenius` equal `F_expt` over `P::Fp_2`, `P::Fp_6`, and `P::Fp_12` (after normalization) using the prime `p : [381] = P::p`.\n","test_setup_code":"","test_list":"","challenge_test_list":""}
{"task_id":40,"type":"function","task":"Define the function `core_verify_pk_in_g1` that verifies a BLS signature in G1 by comparing two `bls_ate_pairing` results (one using the public key and `hash_to_curve_opt(msg, dst)`, and the other using the base point `BP` and the signature), returning an `Fp_12.is_equal` boolean.\n","test_setup_code":"","test_list":"","challenge_test_list":""}
{"task_id":41,"type":"function","task":"Define a Cryptol module `Pairing` that specifies the BLS optimal ate pairing over the BN curve, including `bls_ate_pairing`, `ate_pairing`, the Miller loop (`miller_step`, `line_function`), and the final exponentiation using Frobenius maps, with appropriate types and intermediate helpers.\n","test_setup_code":"","test_list":"","challenge_test_list":""}
{"task_id":42,"type":"function","task":"Specify and verify in Cryptol the BLS key generation procedure `KeyGen_rep` using HKDF-SHA256 and Montgomery arithmetic, including the properties `keygen_finish_integer`, `keygen_finish_bv`, and `le_bytes_from_limbs_rep4_prop` over the defined 256\/512-bit representations.\n","test_setup_code":"","test_list":"","challenge_test_list":""}
{"task_id":43,"type":"function","task":"Write a Cryptol module `Names` that defines the given parameters, types, functions, primitive declarations, and the property `enc_correct : [64] -> Bit` asserting `x == enc (enc x)` for all 64-bit inputs, matching the structure implied by the excerpt.\n","test_setup_code":"","test_list":"","challenge_test_list":""}
{"task_id":44,"type":"function","task":"In Cryptol, define bitvector update functions `update` and `updateEnd` on 16-bit words and properties `wordUpdate`, `wordUpdate2`, `wordUpdateEnd`, and `wordUpdateEnd2` that verify these functions match both mask-based and index-based formulations for indices `y < 16`.\n","test_setup_code":"","test_list":"","challenge_test_list":""}
{"task_id":45,"type":"function","task":"Define the function `xor : {a} ([a], [a]) -> [a]` as element-wise inequality on two sequences, and define `check24` as a property asserting that for all 4-bit `x` and `y`, `xor` equals the built-in bitwise XOR `(^)` and that this holds for all values.\n","test_setup_code":"","test_list":"","challenge_test_list":""}
{"task_id":46,"type":"function","task":"In Cryptol, define the sequence `xs` as given and the value `check28` that asserts the list comprehension `[ x == y | (x,y) <- xs ]` is equal to `~zero`.\n","test_setup_code":"","test_list":"","challenge_test_list":""}
{"task_id":47,"type":"function","task":"In Cryptol, reproduce these parameterized sequence type declarations and their constant zero definitions, ensuring that the arithmetic in the sequence length expressions is well-typed and equivalent (e.g., for f\/g, ff\/gg, jj\/kk).\n","test_setup_code":"","test_list":"","challenge_test_list":""}
{"task_id":48,"type":"function","task":"Write a Cryptol specification that defines the submodules A, S, F, I, and M as given, using a type alias T = [8], an interface submodule S exposing x : T, a functor submodule F using x to define y = 2 * x, and an instantiation M = F { I } with I.x = 28.\n","test_setup_code":"","test_list":"","challenge_test_list":""}
{"task_id":49,"type":"function","task":"Specify the ML-DSA key generation, signing, and verification API and define the property MLDSAIsCorrect that states a signature produced by Sign with keys from KeyGen always verifies with Verify for all messages and contexts within the given type constraints.\n","test_setup_code":"","test_list":"","challenge_test_list":""}
{"task_id":50,"type":"function","task":"Write a Cryptol module that fully specifies the XMSS parameter interface `Primitive::Asymmetric::Signature::XMSS::Parameters`, including types `h`, `n`, `MessageUpperBound`, `PaddingWidth`, constants `oid`, and hash functions `H` and `H_msg` with the given constraints and signatures.\n","test_setup_code":"","test_list":"","challenge_test_list":""}
{"task_id":51,"type":"function","task":"Write a Cryptol module `Primitive::Asymmetric::Signature::XMSS::Instantiations::XMSS_SHA2_10_256` that instantiates the generic XMSS specification with the `XMSS_SHA2_10_256_Parameters` parameter set and the `WOTSP_SHA2_256` WOTS instantiation.\n","test_setup_code":"","test_list":"","challenge_test_list":""}
{"task_id":52,"type":"function","task":"Specify the Keccak\/SHA3 bit and byte ordering utilities, including toBytes, fromBytes, reverseBitOrdering, h2b, b2h, and properties proving involution and mutual inversion (e.g., h2bAndb2hInvert, b2hAndh2bInvert, and example properties).\n","test_setup_code":"","test_list":"","challenge_test_list":""}
{"task_id":53,"type":"function","task":"Write Cryptol properties that verify a SHA224::hash function against known test vectors for inputs \"abc\", the empty string, the 448-bit alphabet string, and the 896-bit alphabet string, matching the specified SHA-224 digest outputs.\n","test_setup_code":"","test_list":"","challenge_test_list":""}
{"task_id":54,"type":"function","task":"Write a Cryptol module that defines the given test vector record types and properties to verify HMAC-SHA-384 and its 192-bit truncation against the RFC 4868 section 2.7.1 and 2.7.2.2 test vectors, using an imported HMAC_SHA384 instantiation.\n","test_setup_code":"","test_list":"","challenge_test_list":""}
{"task_id":55,"type":"function","task":"Define an interface module `Primitive::Symmetric::Cipher::Block::CipherInterface` with type synonyms `KeySize`, `BlockSize`, a finiteness constraint on both, and functions `encrypt` and `decrypt` of type `[KeySize] -> [BlockSize] -> [BlockSize]`.\n","test_setup_code":"","test_list":"","challenge_test_list":""}
{"task_id":56,"type":"property","task":"Implement the property `encryptCorrect` for the CFB mode of operation in the provided Cryptol code. This property should verify that decrypting the ciphertext produced by the `encrypt` function returns the original plaintext. Ensure that your implementation correctly uses the `encrypt` and `decrypt` functions defined in the code.","test_setup_code":"module Primitive::Symmetric::Cipher::Block::Modes::CFB where\nimport interface Primitive::Symmetric::Cipher::Block::CipherInterface as C\n\nencrypt : {s, n} (fin s, fin n, s >= 0, s <= C::BlockSize)\n    => [C::KeySize] -> [C::BlockSize] -> [n][s] -> [n][s]\nencrypt K IV Ps = Cs\n    where\n        CIPH_K = C::encrypt K\n        Is = [ (drop`{s} I_j_1) # C_j_1\n             | I_j_1 <- [IV] # Is\n             | C_j_1 <- Cs\n             ]\n        Cs = [ P_j ^ (take`{s} (CIPH_K I_j))\n             | P_j <- Ps\n             | I_j <- [IV] # Is\n             ]\n\ndecrypt : {s, n} (fin s, fin n, s >= 0, s <= C::BlockSize)\n    => [C::KeySize] -> [C::BlockSize] -> [n][s] -> [n][s]\ndecrypt K IV Cs = Ps\n    where\n        CIPH_K = C::encrypt K\n        Is = [ (drop`{s} I_j_1) # C_j_1\n             | I_j_1 <- [IV] # Is\n             | C_j_1 <- Cs\n             ]\n        Ps = [ C_j ^ (take`{s} (CIPH_K I_j))\n             | C_j <- Cs\n             | I_j <- [IV] # Is\n             ]\n\n","test_list":"","challenge_test_list":""}
{"task_id":57,"type":"function","task":"Define a Cryptol module `Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon128_128` that instantiates the generic Simon block cipher specification for the Simon-128\/128 variant with type parameters `n = 64`, `m = 2`, `T = 68`, and `j = 2`.\n","test_setup_code":"","test_list":"","challenge_test_list":""}
{"task_id":58,"type":"function","task":"Write a Cryptol module `Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon128_256` instantiating the generic Simon block cipher specification for the Simon-128\/256 variant with parameters `n=64`, `m=4`, `T=72`, and `j=4`.\n","test_setup_code":"","test_list":"","challenge_test_list":""}
{"task_id":59,"type":"function","task":"Using only the modules from the supplied Cryptol code, implement the property `aes256_ctr_encrypt_vector` that verifies that the `encrypt` function of the imported module is equal to the `ciphertext` using the following test vectors `k = 0x603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4`, `ic = 0xf0f1f2f3f4f5f6f7f8f9fafbfcfdfeff`, `plaintext = [0x6bc1bee22e409f96e93d7e117393172a, 0xae2d8a571e03ac9c9eb76fac45af8e51, 0x30c81c46a35ce411e5fbc1191a0a52ef, 0xf69f2445df4f9b17ad2b417be66c3710]`, and `ciphertext = [0x601ec313775789a5b7a7f504bbf3d228, 0xf443e3ca4d62b59aca84e990cacaf5c5, 0x2b0930daa23de94ce87017ba2d84988d, 0xdfc9c58db67aada613c2dd08457941a6]`.","test_setup_code":"module Primitive::Symmetric::Cipher::Block::Modes::Tests::AES256_CTR where\nimport Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES256_CTR as AES256_CTR\n\n","test_list":"","challenge_test_list":""}
{"task_id":60,"type":"function","task":"Define a Cryptol module `Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES192_CFB` that instantiates the generic CFB block cipher mode with the AES-192 block cipher implementation.\n","test_setup_code":"","test_list":"","challenge_test_list":""}
{"task_id":61,"type":"function","task":"Write a Cryptol module AES128_CFB that instantiates the generic CFB block cipher mode with AES-128, exposing the resulting AES-128 CFB encryption and decryption functions and any necessary types for keys, blocks, and IVs.\n","test_setup_code":"","test_list":"","challenge_test_list":""}
{"task_id":62,"type":"function","task":"Specify and verify in Cryptol the HostValues module\u2019s heap-based host value store, including VecRepresentation and MapRepresentation constructors, allocation and lookup functions, and define a property that map_representation_equiv correctly characterizes when two MapRepresentation values are equivalent for a given element comparator and heap.\n","test_setup_code":"","test_list":"","challenge_test_list":""}
{"task_id":63,"type":"function","task":"Write a Cryptol specification of the AES-128 S-box over GF(2^8), including gf28Mult, gf28Pow, gf28Inverse, aesAffine, aesSBox, the 16\u00d716 aesSBoxTable, and a property cell00 asserting aesSBoxTable @ 0 @ 0 == 0x63.\n","test_setup_code":"","test_list":"","challenge_test_list":""}
{"task_id":64,"type":"function","task":"Define the functions `usaf : [1][8] -> [10][8] -> [1][8]` and `saf : [1][8] -> [10][8] -> [1][8]` in Cryptol as given, and add a property that they are equal for all inputs `a` and `b` where `0 <= a@0 <= 9`.\n","test_setup_code":"","test_list":"","challenge_test_list":""}
{"task_id":65,"type":"function","task":"Write a Cryptol specification that defines the given Circle\/Displacement\/BMI record types and functions (areaCircle, nudgeCircle, calcBMI, calcBMIimp), along with example constants, matching the behavior and types implied by the code excerpt.\n","test_setup_code":"","test_list":"","challenge_test_list":""}
{"task_id":66,"type":"function","task":"Write a Cryptol specification of ECDSA over the NIST P-384 curve, including functions for key initialization, signing, and public verification, plus properties that check the provided P-384 test vectors for point add\/subtract\/double, scalar multiplication, and twin multiplication.\n","test_setup_code":"","test_list":"","challenge_test_list":""}
{"task_id":67,"type":"function","task":"Write a Cryptol specification that defines the newtype CplxInt over Integer with complex addition, multiplication, equality, and properties cplxAddAssoc, cplxMulAssoc, and cplxMulDistrib verifying associativity of addition, associativity of multiplication, and left distributivity of multiplication over addition.\n","test_setup_code":"","test_list":"","challenge_test_list":""}
{"task_id":68,"type":"function","task":"Write a Cryptol specification that includes the given tuple-based fold functions and a property `foldFunctionInverse` stating that `foldFunction' (foldFunction x y z) y z == x` for all 8-bit `x` and 16-bit `y`, `z`, suitable for formal verification.\n","test_setup_code":"","test_list":"","challenge_test_list":""}
{"task_id":69,"type":"function","task":"Using only the types and functions from the supplied Cryptol code, implement the function `invMixColumns : State -> State` that implements the Inverse MixColumns step of AES on the whole 4\u00d74 state. Only define this function, I will insert it into the file.","test_setup_code":"type GF28 = [8]\ntype Nb = 4\ntype State = [4][Nb * 8]\ngf28Mult : GF28 -> GF28 -> GF28\ngf28Mult x y = pmod (pmult x y) <| x^^8 + x^^4 + x^^3 + x + 1 |>\ntoBytes : [32] -> [4]GF28\ntoBytes x = split`{4} x\nfromBytes : [4]GF28 -> [32]\nfromBytes xs = join xs\nmETable = [gf28Mult 0x0e i | i <- [0 .. 255]]\nmBTable = [gf28Mult 0x0b i | i <- [0 .. 255]]\nmDTable = [gf28Mult 0x0d i | i <- [0 .. 255]]\nm9Table = [gf28Mult 0x09 i | i <- [0 .. 255]]\nmE i = mETable @ i\nmB i = mBTable @ i\nmD i = mDTable @ i\nm9 i = m9Table @ i\ntables =\n  [[mE, mB, mD, m9],\n  [m9, mE, mB, mD],\n  [mD, m9, mE, mB],\n  [mB, mD, m9, mE]]\nfoldr : {a, b, n} (fin n) => (a -> b -> b) -> b -> [n]a -> b\nfoldr f acc xs =\n  ys ! 0\n  where\n    ys = [acc] # [f x a | a <- ys | x <- reverse xs]\nfoldr1 : {a, b} (fin b) => (a -> a -> a) -> [1 + b]a -> a\nfoldr1 f xs = foldr f (xs @ 0) (tail xs)\nzipWith : {a, b, c, n} (a -> b -> c) -> [n]a -> [n]b -> [n]c\nzipWith f xs ys = [f x y | x <- xs | y <- ys]","test_list":"","challenge_test_list":""}
{"task_id":70,"type":"function","task":"Define the Cryptol function `doRounds` and supporting types and functions (`Nb`, `State`, `RoundKey`, `addRoundKey`) as given, where `doRounds` iteratively applies a round function `rnd` over an initial key, a sequence of round keys, and a final key, and verify with a `property` that for any choice of `rnd`, initial key, round keys, final key, and input state, `doRounds` produces the same final state as computing the initial AddRoundKey followed by the same sequence of `rnd` applications unrolled explicitly.\n","test_setup_code":"","test_list":"","challenge_test_list":""}
{"task_id":71,"type":"function","task":"In Cryptol, define the DES S-box 6 constant `sbox6 : [4][16][4]` with the given 4\u00d716 table of 4-bit values exactly as specified here.\n","test_setup_code":"","test_list":"","challenge_test_list":""}
{"task_id":72,"type":"function","task":"Write a Cryptol specification that defines the DES block cipher as a value `DES : Cipher 64 64` (with `encrypt`\/`decrypt` wired through the DES round function, key schedule, permutations, and S-boxes as in the NIST standard) and a property `testsPass` that checks `DES.encrypt` on given test message\/key pairs matches the expected ciphertexts.\n","test_setup_code":"","test_list":"","challenge_test_list":""}
{"task_id":73,"type":"function","task":"Define a Cryptol property rfctest03 that verifies the given ChaCha20 stream cipher implementation (using qround, cdround, core, kexp, iround, stream, and encrypt over types Round, Block, Key, Nonce, and Counter) correctly encrypts the specified msg with the given key and counter to produce the expected out test vector.\n","test_setup_code":"","test_list":"","challenge_test_list":""}
{"task_id":74,"type":"function","task":"Write a Cryptol specification of the ChaCha20 stream cipher with types Round = [16][32], Block = [64][8], Key = [32][8], Nonce = [12][8], Counter = [32], functions qround, cdround, kexp, iround, core, stream, encrypt, and a property rfctest02 that checks encrypt (zero # [1]) 1 (zero # [2]) msg equals the given RFC test vector out for the provided msg bytes.\n","test_setup_code":"","test_list":"","challenge_test_list":""}
{"task_id":75,"type":"function","task":"Write a Cryptol specification that defines the type AESTestVector 128 and the function mct_ecb_decrypt_128 : [128] -> [128] -> [100](AESTestVector 128) implementing the AES-128 Monte Carlo Test for ECB decryption using aesDecryptBlock and aes128DecryptSchedule from SuiteB, including generation of 100 test vectors from an initial key and ciphertext as described.\n","test_setup_code":"","test_list":"","challenge_test_list":""}
{"task_id":76,"type":"function","task":"Define in Cryptol the function `mct_ecb_decrypt_192 : [192] -> [128] -> [100](AESTestVector 192)` and any required types and helpers so that it models the AES-192 Monte Carlo Test for ECB decryption, producing 100 test vectors of key, plaintext, and ciphertext derived from iterative AES-192 decryption and key schedule updates.\n","test_setup_code":"","test_list":"","challenge_test_list":""}
{"task_id":77,"type":"function","task":"Define a Cryptol property tcId1069 that verifies the AES256_KeyWrap padded authenticated-encryption function KWP_AE, instantiated from Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES256_KeyWrap, maps the 8-bit plaintext 0xe0 under the 256-bit key 0x2644ccf9d7c419a437c954c8141cbb2d60f57de10a5393554a14ccc72229e286 to the ciphertext 0xda510b1d9a10255380655980a3a73536, using a helper predicate check_KWP_AE key pt expected_ct = KWP_AE key pt == expected_ct and asserting testPassed == check_KWP_AE key pt ct.\n","test_setup_code":"","test_list":"","challenge_test_list":""}
{"task_id":78,"type":"function","task":"Define the property `tcId1080` that checks, for AES-256 Key Wrap with padding in AE mode, that encrypting the plaintext `0x06` under the key `0x3ea9325069ed93a96c331bdd6dd766ec64bbba83a72c69ed75df55043fb0bfd1` with `KWP_AE` produces the expected ciphertext `0x40a9c42012ba38211b800e6e313b6876`, using the helper `check_KWP_AE key pt expected_ct = KWP_AE key pt == expected_ct`.\n","test_setup_code":"","test_list":"","challenge_test_list":""}
{"task_id":79,"type":"function","task":"Define the Cryptol function `pi16' : [16][64] -> [16][64]` that permutes a 16-word (64-bit each) Threefish state using the index order `[0, 15, 2, 11, 6, 13, 4, 9, 14, 1, 8, 5, 10, 3, 12, 7 : [4]]`, and add a property that this permutation is bijective (has an inverse).\n","test_setup_code":"","test_list":"","challenge_test_list":""}
{"task_id":80,"type":"function","task":"In Cryptol, define the type alias `Dom n = {lo : [n], sz : [n]}` and the functions `interval : {n} (fin n) => [n] -> [n] -> Dom n` and `range : {n} (fin n) => [n] -> [n] -> Dom n` where `interval l s = {lo = l, sz = s}` and `range lo hi = interval lo (hi - lo)`.\n","test_setup_code":"","test_list":"","challenge_test_list":""}
{"task_id":81,"type":"function","task":"In Cryptol, define the type alias `Dom n = {lo : [n], sz : [n]}`, the function `interval : {n} (fin n) => [n] -> [n] -> Dom n` with `interval l s = {lo = l, sz = s}`, and the constant `top : {n} (fin n) => Dom n` defined as `top = interval 0 (~0)`.\n","test_setup_code":"","test_list":"","challenge_test_list":""}
{"task_id":82,"type":"function","task":"Write a Cryptol specification that defines the type `Dom n = {lo : [n], sz : [n]}`, the functions `mem : {n} (fin n) => Dom n -> [n] -> Bit`, `ubounds : {n} (fin n) => Dom n -> ([n], [n])`, `ule : {n} (fin n) => Dom n -> Dom n -> Bit`, the property `correct_ule : {n} (fin n, n >= 1) => Dom n -> Dom n -> [n] -> [n] -> Bit` expressing that `ule a b` implies `x <= y` for all `x` and `y` in the respective domains, and a property instance `o4 = correct_ule` specialized to `n = 16`.\n","test_setup_code":"","test_list":"","challenge_test_list":""}
{"task_id":83,"type":"function","task":"In Cryptol, define the type `Dom n = {lo : [n], sz : [n]}`, functions `interval`, `singleton`, `neg`, `singleton_neg` as in the excerpt, and the property `i08` that asserts `singleton_neg` instantiated at width 16 (i.e., `singleton_neg`{16}) holds for all 16-bit inputs, suitable for verification with a solver.\n","test_setup_code":"","test_list":"","challenge_test_list":""}
{"task_id":84,"type":"function","task":"Write a Cryptol property `Salsa20_passes_tests` that checks the given Salsa20 core implementation (using `quarterround`, `rowround`, `columnround`, `doubleround`, `littleendian`, `littleendian_state`, `littleendian_state_inverse`, `Salsa20_rounds`, and `Salsa20 : [32] -> [64][8] -> [64][8]`) satisfies the three specified 20-round test vectors by equating its outputs to the provided 64-byte expected sequences and conjoining the results.\n","test_setup_code":"","test_list":"","challenge_test_list":""}
